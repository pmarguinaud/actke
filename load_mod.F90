MODULE LOAD_MOD

USE PARKIND1, ONLY : JPIM, JPRB

IMPLICIT NONE

INTERFACE LOAD
MODULE PROCEDURE LOADX0
MODULE PROCEDURE LOADX1
MODULE PROCEDURE LOADX2
MODULE PROCEDURE LOADI0
MODULE PROCEDURE LOADI1
MODULE PROCEDURE LOADI2
MODULE PROCEDURE LOADL0
MODULE PROCEDURE LOADC0
END INTERFACE LOAD

INTERFACE DIFF
MODULE PROCEDURE DIFFX0
MODULE PROCEDURE DIFFX1
MODULE PROCEDURE DIFFX2
MODULE PROCEDURE DIFFI0
MODULE PROCEDURE DIFFL0
MODULE PROCEDURE DIFFC0
END INTERFACE DIFF

INTEGER, PARAMETER :: ILUN_IN = 77, ILUN_OUT = 88, ILUNC = 99

CONTAINS

SUBROUTINE OPEN_LOAD (CDFILE)
CHARACTER (LEN=*) :: CDFILE
OPEN (ILUN_IN, FILE=TRIM (CDFILE)//'.IN', FORM="UNFORMATTED", ACTION="READ")
OPEN (ILUN_OUT, FILE=TRIM (CDFILE)//'.OUT', FORM="UNFORMATTED", ACTION="READ")
END SUBROUTINE OPEN_LOAD

SUBROUTINE CLOSE_LOAD
CLOSE (ILUN_IN)
CLOSE (ILUN_OUT)
END SUBROUTINE CLOSE_LOAD

SUBROUTINE DIFFX0 (CDNAME, X0, X0_1)
CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRB) :: X0, X0_1
IF (X0 /= X0_1) THEN
  WRITE (*, '(A32,12X,3E25.17)') CDNAME, X0, X0_1, X0_1 - X0
ENDIF
END SUBROUTINE DIFFX0

SUBROUTINE LOADX0 (ILUN, X0) 
INTEGER          :: ILUN
REAL (KIND=JPRB) :: X0
READ (ILUN) X0
END SUBROUTINE LOADX0

SUBROUTINE DIFFX1 (CDNAME, X1, X1_1)
CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRB) :: X1 (:), X1_1 (:) 
INTEGER :: I1
DO I1 = 1, SIZE (X1)
  IF (X1 (I1) /= X1_1 (I1)) THEN
    WRITE (*, '(A32,I12,12X,3E25.17)') CDNAME, I1, X1 (I1), X1_1 (I1), X1_1 (I1) - X1 (I1)
  ENDIF
ENDDO
END SUBROUTINE DIFFX1

SUBROUTINE LOADX1 (ILUN, X1) 
INTEGER                   :: ILUN
REAL (KIND=JPRB), POINTER :: X1 (:) 
INTEGER :: IL (1), IB (1) 
READ (ILUN) IL
READ (ILUN) IB
ALLOCATE (X1 (IL (1): IB (1)))
READ (ILUN) X1
END SUBROUTINE LOADX1

SUBROUTINE DIFFX2 (CDNAME, X2, X2_1)
CHARACTER (LEN=*) :: CDNAME
REAL (KIND=JPRB) :: X2 (:,:), X2_1 (:,:)
INTEGER :: I1, I2
DO I1 = 1, SIZE (X2, 1)
DO I2 = 1, SIZE (X2, 2)
  IF (X2 (I1, I2) /= X2_1 (I1, I2)) THEN
    WRITE (*, '(A32,I12,I12,3E25.17)') CDNAME, I1, I2, X2 (I1, I2), X2_1 (I1, I2), X2_1 (I1, I2) - X2 (I1, I2)
  ENDIF
ENDDO
ENDDO
END SUBROUTINE DIFFX2

SUBROUTINE LOADX2 (ILUN, X2)
INTEGER                   :: ILUN
REAL (KIND=JPRB), POINTER :: X2 (:,:)
INTEGER :: IL (2), IB (2)
READ (ILUN) IL
READ (ILUN) IB
ALLOCATE (X2 (IL (1): IB (1), IL (2): IB (2)))
READ (ILUN) X2
END SUBROUTINE LOADX2

SUBROUTINE DIFFI0 (CDNAME, I0, I0_1)
CHARACTER (LEN=*) :: CDNAME
INTEGER :: I0, I0_1
IF (I0 /= I0_1) THEN
  WRITE (*, '(A32,12X,12X,3I25)') CDNAME, I0, I0_1, I0-I0_1
ENDIF
END SUBROUTINE DIFFI0

SUBROUTINE LOADI0 (ILUN, I0)
INTEGER             :: ILUN
INTEGER (KIND=JPIM) :: I0
READ (ILUN) I0
END SUBROUTINE LOADI0

SUBROUTINE LOADI1 (ILUN, I1) 
INTEGER                   :: ILUN
INTEGER (KIND=JPIM), POINTER :: I1 (:) 
INTEGER :: IL (1), IB (1) 
READ (ILUN) IL
READ (ILUN) IB
ALLOCATE (I1 (IL (1): IB (1)))
READ (ILUN) I1
END SUBROUTINE LOADI1

SUBROUTINE LOADI2 (ILUN, I2)
INTEGER                   :: ILUN
INTEGER (KIND=JPIM), POINTER :: I2 (:,:)
INTEGER :: IL (2), IB (2)
READ (ILUN) IL
READ (ILUN) IB
ALLOCATE (I2 (IL (1): IB (1), IL (2): IB (2)))
READ (ILUN) I2
END SUBROUTINE LOADI2

SUBROUTINE DIFFL0 (CDNAME, L0, L0_1)
CHARACTER (LEN=*) :: CDNAME
LOGICAL :: L0, L0_1
IF (.NOT. (L0 .EQV. L0_1)) THEN
  WRITE (*, '(A32,24X,3L25)') CDNAME, L0, L0_1, .FALSE.
ENDIF
END SUBROUTINE DIFFL0

SUBROUTINE LOADL0 (ILUN, L0)
INTEGER :: ILUN
LOGICAL :: L0
READ (ILUN) L0
END SUBROUTINE LOADL0

SUBROUTINE DIFFC0 (CDNAME, C0, C0_1)
CHARACTER (LEN=*) :: CDNAME
CHARACTER (LEN=*) :: C0, C0_1
IF (C0 .NE. C0_1) THEN
  WRITE (*, '(A32,24X,2A25)') CDNAME, C0, C0_1
ENDIF
END SUBROUTINE DIFFC0

SUBROUTINE LOADC0 (ILUN, C0)
INTEGER           :: ILUN
CHARACTER (LEN=*) :: C0
READ (ILUN) C0
END SUBROUTINE LOADC0

END MODULE LOAD_MOD

